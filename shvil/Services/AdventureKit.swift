//
//  AdventureKit.swift
//  shvil
//
//  Created by ilan on 2024.
//

import CoreLocation
import Foundation
import MapKit

// MARK: - Adventure Models

/// Adventure plan generated by AI with structured chapters
public struct AdventurePlan: Codable, Identifiable {
    public let id: UUID
    public let title: String
    public let description: String
    public let theme: AdventureMood
    public let stops: [AdventureStop]
    public let totalDuration: Int // in minutes
    public let totalDistance: Double // in meters
    public let budgetLevel: BudgetLevel
    public let status: AdventureStatus
    public let createdAt: Date
    public let updatedAt: Date

    public init(
        id: UUID = UUID(),
        title: String,
        description: String,
        theme: AdventureMood,
        stops: [AdventureStop],
        totalDuration: Int,
        totalDistance: Double,
        budgetLevel: BudgetLevel,
        status: AdventureStatus = .draft,
        createdAt: Date = Date(),
        updatedAt: Date = Date()
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.theme = theme
        self.stops = stops
        self.totalDuration = totalDuration
        self.totalDistance = totalDistance
        self.budgetLevel = budgetLevel
        self.status = status
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }
}





/// Constraints for adventure stops
public struct StopConstraints: Codable {
    public let openLate: Bool
    public let budget: BudgetLevel
    public let accessibility: Bool
    public let outdoor: Bool

    public init(
        openLate: Bool = false,
        budget: BudgetLevel = .medium,
        accessibility: Bool = true,
        outdoor: Bool = false
    ) {
        self.openLate = openLate
        self.budget = budget
        self.accessibility = accessibility
        self.outdoor = outdoor
    }
}

/// Budget levels for adventure stops
public enum BudgetLevel: String, CaseIterable, Codable {
    case low
    case medium
    case high

    public var displayName: String {
        switch self {
        case .low: "Budget-Friendly"
        case .medium: "Moderate"
        case .high: "Premium"
        }
    }
}


// MARK: - Adventure Generation Input

/// Input parameters for adventure generation
public struct AdventureGenerationInput: Codable {
    public let timeFrame: TimeFrame
    public let mood: AdventureMood
    public let budget: BudgetLevel
    public let companions: [CompanionType]
    public let transportationMode: TransportationMode
    public let origin: CLLocationCoordinate2D
    public let preferences: UserPreferences

    public init(
        timeFrame: TimeFrame,
        mood: AdventureMood,
        budget: BudgetLevel,
        companions: [CompanionType],
        transportationMode: TransportationMode,
        origin: CLLocationCoordinate2D,
        preferences: UserPreferences
    ) {
        self.timeFrame = timeFrame
        self.mood = mood
        self.budget = budget
        self.companions = companions
        self.transportationMode = transportationMode
        self.origin = origin
        self.preferences = preferences
    }
}


/// Time frames for adventures
public enum TimeFrame: String, CaseIterable, Codable {
    case halfDay
    case fullDay
    case weekend
    case week

    public var displayName: String {
        switch self {
        case .halfDay: "Half Day (4-6 hours)"
        case .fullDay: "Full Day (8-12 hours)"
        case .weekend: "Weekend (2-3 days)"
        case .week: "Week (5-7 days)"
        }
    }
}

/// Companion types for adventures
public enum CompanionType: String, CaseIterable, Codable {
    case solo
    case couple
    case family
    case friends
    case business

    public var displayName: String {
        switch self {
        case .solo: "Solo"
        case .couple: "Couple"
        case .family: "Family"
        case .friends: "Friends"
        case .business: "Business"
        }
    }
}


// MARK: - AdventureKit Service

/// Main service for adventure management
@MainActor
public class AdventureKit: ObservableObject {
    @Published public var currentAdventure: AdventurePlan?
    @Published public var adventureHistory: [AdventurePlan] = []
    @Published public var isGenerating = false
    @Published public var error: Error?

    private let aiKit: AIKit
    private let mapEngine: MapEngine
    private let safetyKit: SafetyKit
    private let persistence: Persistence

    public init(
        aiKit: AIKit,
        mapEngine: MapEngine,
        safetyKit: SafetyKit,
        persistence: Persistence
    ) {
        self.aiKit = aiKit
        self.mapEngine = mapEngine
        self.safetyKit = safetyKit
        self.persistence = persistence
    }

    /// Generate a new adventure plan
    public func generateAdventure(input: AdventureGenerationInput) async throws -> AdventurePlan {
        isGenerating = true
        defer { isGenerating = false }

        do {
            // Generate adventure plan using AI
            let plan = try await aiKit.generateAdventurePlan(input: input)

            // Validate stops with MapEngine
            let validatedPlan = try await validateAdventureStops(plan)

            // Filter for safety
            let safePlan = try await filterAdventureForSafety(validatedPlan)

            // Cache the adventure
            try await persistence.saveAdventure(safePlan)

            return safePlan
        } catch {
            self.error = error
            throw error
        }
    }

    /// Start an adventure
    public func startAdventure(_ adventure: AdventurePlan) {
        currentAdventure = adventure
        // Update status to active
        // Start navigation to first stop
    }

    /// Complete an adventure
    public func completeAdventure() {
        guard var adventure = currentAdventure else { return }

        adventure = AdventurePlan(
            id: adventure.id,
            title: adventure.title,
            description: adventure.description,
            theme: adventure.theme,
            stops: adventure.stops,
            totalDuration: adventure.totalDuration,
            totalDistance: adventure.totalDistance,
            budgetLevel: adventure.budgetLevel,
            status: .completed,
            createdAt: adventure.createdAt,
            updatedAt: Date()
        )

        adventureHistory.append(adventure)
        currentAdventure = nil

        // Save to persistence
        Task {
            try await persistence.saveAdventure(adventure)
        }
    }

    /// Swap a stop in the current adventure
    public func swapStop(stopId: UUID, with alternative: AdventureStop) async throws {
        guard var adventure = currentAdventure else { return }

        // Find and replace the stop
        var updatedStops = adventure.stops
        if let index = updatedStops.firstIndex(where: { $0.id == stopId }) {
            updatedStops[index] = alternative
        }

        // Update adventure
        adventure = AdventurePlan(
            id: adventure.id,
            title: adventure.title,
            description: adventure.description,
            theme: adventure.theme,
            stops: updatedStops,
            totalDuration: adventure.totalDuration,
            totalDistance: adventure.totalDistance,
            budgetLevel: adventure.budgetLevel,
            status: adventure.status,
            createdAt: adventure.createdAt,
            updatedAt: Date()
        )

        currentAdventure = adventure

        // Save to persistence
        try await persistence.saveAdventure(adventure)
    }

    /// Generate alternatives for a stop
    public func generateAlternatives(for stop: AdventureStop, input: AdventureGenerationInput) async throws -> [AdventureStop] {
        try await aiKit.generateStopAlternatives(stop: stop, input: input)
    }

    // MARK: - Private Methods

    private func validateAdventureStops(_ plan: AdventurePlan) async throws -> AdventurePlan {
        var validatedStops: [AdventureStop] = []

        for stop in plan.stops {
            // Use MapEngine to find real POIs for this stop
            let searchResults = try await mapEngine.searchPlaces(
                query: stop.name,
                region: MKCoordinateRegion(
                    center: stop.location.coordinate,
                    latitudinalMeters: 1000,
                    longitudinalMeters: 1000
                )
            )

            if let bestMatch = searchResults.first {
                let validatedStop = AdventureStop(
                    id: stop.id,
                    name: bestMatch.name,
                    description: stop.description,
                    location: LocationData(
                        latitude: bestMatch.latitude,
                        longitude: bestMatch.longitude,
                        address: bestMatch.address
                    ),
                    category: stop.category,
                    estimatedDuration: stop.estimatedDuration
                )
                validatedStops.append(validatedStop)
            } else {
                // Keep original stop if no match found
                validatedStops.append(stop)
            }
        }

        return AdventurePlan(
            id: plan.id,
            title: plan.title,
            description: plan.description,
            theme: plan.theme,
            stops: validatedStops,
            totalDuration: plan.totalDuration,
            totalDistance: plan.totalDistance,
            budgetLevel: plan.budgetLevel,
            status: plan.status,
            createdAt: plan.createdAt,
            updatedAt: plan.updatedAt
        )
    }

    private func filterAdventureForSafety(_ plan: AdventurePlan) async throws -> AdventurePlan {
        var safeStops: [AdventureStop] = []

        for stop in plan.stops {
            guard stop.location.latitude != 0 && stop.location.longitude != 0 else {
                safeStops.append(stop)
                continue
            }

            // Check safety reports for this location
            // TODO: Fix getSafetyReports method visibility issue
            // let safetyReports = try await safetyKit.getSafetyReports(
            //     near: coordinate,
            //     radius: 500 // 500m radius
            // )
            let safetyReports: [SafetyReport] = []

            // Filter out stops with recent safety issues
            let recentReports = safetyReports.filter {
                Date().timeIntervalSince($0.createdAt) < 3600 // Last hour
            }

            if recentReports.isEmpty {
                safeStops.append(stop)
            }
        }

        return AdventurePlan(
            id: plan.id,
            title: plan.title,
            description: plan.description,
            theme: plan.theme,
            stops: safeStops,
            totalDuration: plan.totalDuration,
            totalDistance: plan.totalDistance,
            budgetLevel: plan.budgetLevel,
            status: plan.status,
            createdAt: plan.createdAt,
            updatedAt: plan.updatedAt
        )
    }
}

