//
//  AdventureKit.swift
//  shvil
//
//  Created by ilan on 2024.
//

import Foundation
import CoreLocation
import MapKit

// MARK: - Adventure Models

/// Adventure plan generated by AI with structured chapters
public struct AdventurePlan: Codable, Identifiable {
    public let id: UUID
    public let title: String
    public let tagline: String
    public let theme: String
    public let mood: AdventureMood
    public let durationHours: Int
    public let isGroup: Bool
    public let stops: [AdventureStop]
    public let notes: String
    public let createdAt: Date
    public let status: AdventureStatus
    
    public init(
        id: UUID = UUID(),
        title: String,
        tagline: String,
        theme: String,
        mood: AdventureMood,
        durationHours: Int,
        isGroup: Bool,
        stops: [AdventureStop],
        notes: String,
        createdAt: Date = Date(),
        status: AdventureStatus = .draft
    ) {
        self.id = id
        self.title = title
        self.tagline = tagline
        self.theme = theme
        self.mood = mood
        self.durationHours = durationHours
        self.isGroup = isGroup
        self.stops = stops
        self.notes = notes
        self.createdAt = createdAt
        self.status = status
    }
}

/// Individual stop in an adventure
public struct AdventureStop: Codable, Identifiable {
    public let id: UUID
    public let chapter: String
    public let category: StopCategory
    public let idealDurationMin: Int
    public let narrative: String
    public let constraints: StopConstraints
    public let placeId: String?
    public let name: String?
    public let address: String?
    public let coordinate: CLLocationCoordinate2D?
    public let startHintTimestamp: Date?
    public let stayMinutes: Int?
    
    public init(
        id: UUID = UUID(),
        chapter: String,
        category: StopCategory,
        idealDurationMin: Int,
        narrative: String,
        constraints: StopConstraints,
        placeId: String? = nil,
        name: String? = nil,
        address: String? = nil,
        coordinate: CLLocationCoordinate2D? = nil,
        startHintTimestamp: Date? = nil,
        stayMinutes: Int? = nil
    ) {
        self.id = id
        self.chapter = chapter
        self.category = category
        self.idealDurationMin = idealDurationMin
        self.narrative = narrative
        self.constraints = constraints
        self.placeId = placeId
        self.name = name
        self.address = address
        self.coordinate = coordinate
        self.startHintTimestamp = startHintTimestamp
        self.stayMinutes = stayMinutes
    }
}

/// Adventure mood types
public enum AdventureMood: String, CaseIterable, Codable {
    case fun = "fun"
    case relaxing = "relaxing"
    case cultural = "cultural"
    case romantic = "romantic"
    case adventurous = "adventurous"
    
    public var displayName: String {
        switch self {
        case .fun: return "Fun & Playful"
        case .relaxing: return "Relaxing & Chill"
        case .cultural: return "Cultural & Educational"
        case .romantic: return "Romantic & Intimate"
        case .adventurous: return "Adventurous & Bold"
        }
    }
}

/// Stop categories for adventure planning
public enum StopCategory: String, CaseIterable, Codable {
    case landmark = "landmark"
    case food = "food"
    case scenic = "scenic"
    case museum = "museum"
    case activity = "activity"
    case nightlife = "nightlife"
    case hiddenGem = "hidden_gem"
    
    public var displayName: String {
        switch self {
        case .landmark: return "Landmark"
        case .food: return "Food & Drink"
        case .scenic: return "Scenic View"
        case .museum: return "Museum"
        case .activity: return "Activity"
        case .nightlife: return "Nightlife"
        case .hiddenGem: return "Hidden Gem"
        }
    }
}

/// Constraints for adventure stops
public struct StopConstraints: Codable {
    public let openLate: Bool
    public let budget: BudgetLevel
    public let accessibility: Bool
    public let outdoor: Bool
    
    public init(
        openLate: Bool = false,
        budget: BudgetLevel = .medium,
        accessibility: Bool = true,
        outdoor: Bool = false
    ) {
        self.openLate = openLate
        self.budget = budget
        self.accessibility = accessibility
        self.outdoor = outdoor
    }
}

/// Budget levels for adventure stops
public enum BudgetLevel: String, CaseIterable, Codable {
    case low = "low"
    case medium = "medium"
    case high = "high"
    
    public var displayName: String {
        switch self {
        case .low: return "Budget-Friendly"
        case .medium: return "Moderate"
        case .high: return "Premium"
        }
    }
}

/// Adventure status
public enum AdventureStatus: String, CaseIterable, Codable {
    case draft = "draft"
    case active = "active"
    case completed = "completed"
    case cancelled = "cancelled"
    
    public var displayName: String {
        switch self {
        case .draft: return "Draft"
        case .active: return "Active"
        case .completed: return "Completed"
        case .cancelled: return "Cancelled"
        }
    }
}

// MARK: - Adventure Generation Input

/// Input parameters for adventure generation
public struct AdventureGenerationInput: Codable {
    public let theme: String
    public let durationHours: Int
    public let mood: AdventureMood
    public let isGroup: Bool
    public let city: String
    public let timeOfDay: String
    public let weather: String
    public let preferences: UserPreferences
    public let savedPlaces: [String]
    public let recentPlaces: [String]
    
    public init(
        theme: String,
        durationHours: Int,
        mood: AdventureMood,
        isGroup: Bool,
        city: String,
        timeOfDay: String,
        weather: String,
        preferences: UserPreferences,
        savedPlaces: [String] = [],
        recentPlaces: [String] = []
    ) {
        self.theme = theme
        self.durationHours = durationHours
        self.mood = mood
        self.isGroup = isGroup
        self.city = city
        self.timeOfDay = timeOfDay
        self.weather = weather
        self.preferences = preferences
        self.savedPlaces = savedPlaces
        self.recentPlaces = recentPlaces
    }
}

/// User preferences for adventure generation
public struct UserPreferences: Codable {
    public let transportation: [TransportationMode]
    public let interests: [String]
    public let avoidCrowds: Bool
    public let maxWalkingDistance: Int // meters
    
    public init(
        transportation: [TransportationMode] = [.walking],
        interests: [String] = [],
        avoidCrowds: Bool = false,
        maxWalkingDistance: Int = 1000
    ) {
        self.transportation = transportation
        self.interests = interests
        self.avoidCrowds = avoidCrowds
        self.maxWalkingDistance = maxWalkingDistance
    }
}

/// Transportation modes for adventures
public enum TransportationMode: String, CaseIterable, Codable {
    case walking = "walking"
    case driving = "driving"
    case cycling = "cycling"
    case publicTransport = "public_transport"
    
    public var displayName: String {
        switch self {
        case .walking: return "Walking"
        case .driving: return "Driving"
        case .cycling: return "Cycling"
        case .publicTransport: return "Public Transport"
        }
    }
}

// MARK: - AdventureKit Service

/// Main service for adventure management
@MainActor
public class AdventureKit: ObservableObject {
    @Published public var currentAdventure: AdventurePlan?
    @Published public var adventureHistory: [AdventurePlan] = []
    @Published public var isGenerating = false
    @Published public var error: Error?
    
    private let aiKit: AIKit
    private let mapEngine: MapEngine
    private let safetyKit: SafetyKit
    private let persistence: Persistence
    
    public init(
        aiKit: AIKit,
        mapEngine: MapEngine,
        safetyKit: SafetyKit,
        persistence: Persistence
    ) {
        self.aiKit = aiKit
        self.mapEngine = mapEngine
        self.safetyKit = safetyKit
        self.persistence = persistence
    }
    
    /// Generate a new adventure plan
    public func generateAdventure(input: AdventureGenerationInput) async throws -> AdventurePlan {
        isGenerating = true
        defer { isGenerating = false }
        
        do {
            // Generate adventure plan using AI
            let plan = try await aiKit.generateAdventurePlan(input: input)
            
            // Validate stops with MapEngine
            let validatedPlan = try await validateAdventureStops(plan)
            
            // Filter for safety
            let safePlan = try await filterAdventureForSafety(validatedPlan)
            
            // Cache the adventure
            try await persistence.saveAdventure(safePlan)
            
            return safePlan
        } catch {
            self.error = error
            throw error
        }
    }
    
    /// Start an adventure
    public func startAdventure(_ adventure: AdventurePlan) {
        currentAdventure = adventure
        // Update status to active
        // Start navigation to first stop
    }
    
    /// Complete an adventure
    public func completeAdventure() {
        guard var adventure = currentAdventure else { return }
        
        adventure = AdventurePlan(
            id: adventure.id,
            title: adventure.title,
            tagline: adventure.tagline,
            theme: adventure.theme,
            mood: adventure.mood,
            durationHours: adventure.durationHours,
            isGroup: adventure.isGroup,
            stops: adventure.stops,
            notes: adventure.notes,
            createdAt: adventure.createdAt,
            status: .completed
        )
        
        adventureHistory.append(adventure)
        currentAdventure = nil
        
        // Save to persistence
        Task {
            try await persistence.saveAdventure(adventure)
        }
    }
    
    /// Swap a stop in the current adventure
    public func swapStop(stopId: UUID, with alternative: AdventureStop) async throws {
        guard var adventure = currentAdventure else { return }
        
        // Find and replace the stop
        var updatedStops = adventure.stops
        if let index = updatedStops.firstIndex(where: { $0.id == stopId }) {
            updatedStops[index] = alternative
        }
        
        // Update adventure
        adventure = AdventurePlan(
            id: adventure.id,
            title: adventure.title,
            tagline: adventure.tagline,
            theme: adventure.theme,
            mood: adventure.mood,
            durationHours: adventure.durationHours,
            isGroup: adventure.isGroup,
            stops: updatedStops,
            notes: adventure.notes,
            createdAt: adventure.createdAt,
            status: adventure.status
        )
        
        currentAdventure = adventure
        
        // Save to persistence
        try await persistence.saveAdventure(adventure)
    }
    
    /// Generate alternatives for a stop
    public func generateAlternatives(for stop: AdventureStop, input: AdventureGenerationInput) async throws -> [AdventureStop] {
        return try await aiKit.generateStopAlternatives(stop: stop, input: input)
    }
    
    // MARK: - Private Methods
    
    private func validateAdventureStops(_ plan: AdventurePlan) async throws -> AdventurePlan {
        var validatedStops: [AdventureStop] = []
        
        for stop in plan.stops {
            // Use MapEngine to find real POIs for this stop
            let searchResults = try await mapEngine.searchPlaces(
                query: stop.chapter
            )
            
            if let bestMatch = searchResults.first {
                let validatedStop = AdventureStop(
                    id: stop.id,
                    chapter: stop.chapter,
                    category: stop.category,
                    idealDurationMin: stop.idealDurationMin,
                    narrative: stop.narrative,
                    constraints: stop.constraints,
                    placeId: bestMatch.mapItem?.name,
                    name: bestMatch.name,
                    address: bestMatch.address,
                    coordinate: bestMatch.coordinate,
                    startHintTimestamp: stop.startHintTimestamp,
                    stayMinutes: stop.stayMinutes
                )
                validatedStops.append(validatedStop)
            } else {
                // Keep original stop if no match found
                validatedStops.append(stop)
            }
        }
        
        return AdventurePlan(
            id: plan.id,
            title: plan.title,
            tagline: plan.tagline,
            theme: plan.theme,
            mood: plan.mood,
            durationHours: plan.durationHours,
            isGroup: plan.isGroup,
            stops: validatedStops,
            notes: plan.notes,
            createdAt: plan.createdAt,
            status: plan.status
        )
    }
    
    private func filterAdventureForSafety(_ plan: AdventurePlan) async throws -> AdventurePlan {
        var safeStops: [AdventureStop] = []
        
        for stop in plan.stops {
            guard stop.coordinate != nil else {
                safeStops.append(stop)
                continue
            }
            
            // Check safety reports for this location
            // TODO: Fix getSafetyReports method visibility issue
            // let safetyReports = try await safetyKit.getSafetyReports(
            //     near: coordinate,
            //     radius: 500 // 500m radius
            // )
            let safetyReports: [SafetyReport] = []
            
            // Filter out stops with recent safety issues
            let recentReports = safetyReports.filter { 
                Date().timeIntervalSince($0.createdAt) < 3600 // Last hour
            }
            
            if recentReports.isEmpty {
                safeStops.append(stop)
            }
        }
        
        return AdventurePlan(
            id: plan.id,
            title: plan.title,
            tagline: plan.tagline,
            theme: plan.theme,
            mood: plan.mood,
            durationHours: plan.durationHours,
            isGroup: plan.isGroup,
            stops: safeStops,
            notes: plan.notes,
            createdAt: plan.createdAt,
            status: plan.status
        )
    }
}

// MARK: - CLLocationCoordinate2D Codable Extension

extension CLLocationCoordinate2D: Codable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(latitude, forKey: .latitude)
        try container.encode(longitude, forKey: .longitude)
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let latitude = try container.decode(Double.self, forKey: .latitude)
        let longitude = try container.decode(Double.self, forKey: .longitude)
        self.init(latitude: latitude, longitude: longitude)
    }
    
    private enum CodingKeys: String, CodingKey {
        case latitude, longitude
    }
}
